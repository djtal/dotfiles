#!/bin/bash

# cannot use it now since in tty it exit when grep find nothing
# set -e


K_TTY_SHELL="${DEFAULT_K_TTY_SHELL:-/bin/sh}" 
K_PROJECT_CONFIG_FILE=".kproject" 

usage() {
cat <<EOF
Kubernetes project aware utility
k will help you run you daily dev task for app running inside kubernetes
k usage:
  k subcommand

  Lot of subcommand can be configured via a .kproject file in your project

  Available subcommands

  psql            open a psql console on the current app database
  reset           restart the application by using the ./bin/kube_reset_app script if present
  status, st      show pod(s) status for the current app
  subcommands     list all available subcommands. Uselfull for autocompletion
  tty             open a shell directly on the selected application/pod
  help            display this help message
  general:
    -h, --help    print this message
EOF
}

subcommand=$1

if [[ $subcommand == '-h' || $subcommand == '--help' || $subcommand == '-?' ]]; then
    usage
    exit 0
fi


# read project label from 
# .kproject file if preent
# present you list of uniq pod app label to select one
function select_k8_app()  {
  if [ -f .kproject ]; then
    head -n 1 "$K_PROJECT_CONFIG_FILE"
  else
    kubectl get pods  -o=jsonpath="{.items[*].metadata.labels.app}" | tr ' ' '\n' | uniq | fzf --header='App :'
  fi
}

function kstatus() {
  selected=$(select_k8_app)
  status=$(kubectl get pod -l app="$selected" -o jsonpath='{.items[0].status.containerStatuses[0].ready}')
  echo "$status"
}

function kreset() {
  if [[ ! -f ./bin/kube_reset_app ]]; then
    echo "No ./bin/kube_reset_app to execute"
    exit 1
  fi

  cur=$(kubectl config current-context)
  if [ "vagrant" == "$cur" ]; then
      ./bin/kube_reset_app
  else
    kubectl config use-context vagrant
    # TODO trap here to restore context
    ./bin/kube_reset_app
    kubectl config use-context "$cur"
  fi
}

function klog() {
  selected=$(select_k8_app)
  if [[ ! -z "$selected" ]]; then
    stern "$selected" --exclude "(/health/all|/api/public/build_version/)" --tail 100
  else
    echo "No application to tail log for"
  fi
}

function kpod() {
  selected=$(select_k8_app)
  kubectl get pod -l app="$selected" -o wide --no-headers
}

# read shell to use from by priority
# 1. k8 pod annoations k-shell 
# 2. .kproject file line with shell=/you/shell/here
# 3. default to /bin/sh if not present
function ktty() {
  selected=$(select_k8_app)
  if [[ ! -z "$selected" ]]; then
    pod=$(kubectl get pod -l "app=$selected" -o jsonpath='{.items[0].metadata.name}')
    # try reading shell from pod annotations
    shell=$(kubectl get pod -l "app=$selected" -o jsonpath='{.items[0].metadata.annotations.k-shell}')
    if [[ -z "$shell" ]]; then
      kshell=$(grep "shell" "$K_PROJECT_CONFIG_FILE")
      if [ $? -eq 0 ]; then
        shell=${kshell#*=}
        from='./kproject'
      else
        shell="$K_TTY_SHELL"
        from='default'
      fi
    else
      from='k-shell annotation'
    fi
    if [[ ! -z "$pod" ]]; then
      echo "Log into: $selected ($pod) with: $shell (from $from)"
      kubectl exec -ti "$pod" -- "$shell" -l 
    fi
  fi
}

case $subcommand in
  log)
    klog 
    ;;
  pod)
    kpod
    ;;
  psql)
    if [[ -f "$HOME/.pg_services" ]]; then
      echo "No ~/.pg_services defined"
      exit 1
    fi
    psql  service="$(basename "$(pwd)")"
    ;;
  reset)
    kreset
    ;;
  status)
    kstatus
    ;;
  st)
    kstatus
    ;;
  subcommands)
    echo log pod psql reset status st tty 
    ;;
  tty)
    ktty
    ;;
  *) 
    echo "nothing to do"
    ;;
esac
