# vim:filetype=sh
# we are not running inside simple sh so ignore thoses error
# shellcheck disable=SC2039
# all these function are intended to use in bash in daily usage
# shellcheck disable=SC2112

function cddev() {
  if [ -z "$1" ]; then
    cd "${CD_DEV_PATH/#\~/$HOME}" || exit
  else
    dir=$(find "${CD_DEV_PATH/#\~/$HOME}" -mindepth 1 -maxdepth 1 -name "$1" -type d | head -n 1)
    if [ "$dir" ]; then
      cd "$dir" || exit
      # set tab title to directory name
      echo -ne "\033]0;$1\007"
    else
      echo "Aucun projet '$1' trouvÃ©..." >&2
      return 1
    fi
  fi
}

function _devs() {
  local cur
  cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( $(find "${CD_DEV_PATH/#\~/$HOME}"  -mindepth 1 -maxdepth 1 ! -name '.*' -name "$cur*" -type d -exec basename {} \;) )
}
complete -F _devs cddev


# see https://github.com/bag-man/dotfiles/blob/c88cc454e1ba2a86d2b596b2cee55e61eecf6162/bashrc
# Updated to use fzf if no args given
# Usage tm [session-name]
tm() {
  if [[ $1 == '-h' || $1 == '--help' || $1 == '-?' ]]; then
    echo "Connect to a tmux session"
    echo "Usage: tm [session-name]"
    return 0
  fi
  [[ -n "$TMUX" ]] && change="switch-client" || change="attach-session"
  if [ "$1" ]; then
    tmux "$change" -t "$1" 2>/dev/null || (tmux new-session -d -s "$1" && tmux "$change" -t "$1"); return
  fi
  session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | fzf --exit-0) &&  tmux $change -t "$session" || echo "No sessions found."
}

# AUtocompletion for tmux sessions
# see https://gist.github.com/jyurek/7be666a88e06f68d45cf
_tmux_complete_session() {
  local IFS=$'\n'
  local cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( ${COMPREPLY[@]:-} $(compgen -W "$(tmux -q list-sessions | cut -f 1 -d ':')" -- "${cur}") )
}
complete -F _tmux_complete_session tm

# Pow managment

# easy add app rails app to pow
#
function power() {
  app_path=$(pwd)
  app_name=$1
  : ${app_name:="$(basename $app_path)"}
  ln -nfs $app_path ~/.pow/$app_name
  echo "application avalaible at ${app_name}.dev"
}

function powlog() {
  app_path=$(pwd)
  app_name=$1
  : ${app_name:="$(basename $app_path)"}
  tail -f /Users/djtal/Library/Logs/Pow/apps/${app_name}.log
}

function repow() {
  launchctl stop cx.pow.powd
}

function powaaaa() {
  curl --silent -H host:pow localhost/status.json | python -mjson.tool
}

# Quick Rails 2.3 alias

function rdm() { bundle exec rake db:migrate "$@"; }
function rsc() {
  if [ -f script/console ]; then
    bundle exec script/console "$@";
  elif [ -d bin ]; then
    bundle exec bin/rails c
  else
    bundle exec rails c "$@"
  fi
  }
function sdc() { ./script/dbconsole -p "$@"; }
function tlf() { tail -f log/${RAILS_ENV:-development}.log; }

# extract any time of compressed file
# source https://coderwall.com/p/arwifq?i=9&p=1&q=sort%3Ascore+desc&t%5B%5D=bash
function extract() {
    echo Extracting $1 ...
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1  ;;
            *.tar.gz)    tar xzf $1  ;;
            *.bz2)       bunzip2 $1  ;;
            *.rar)       rar x $1    ;;
            *.gz)        gunzip $1   ;;
            *.tar)       tar xf $1   ;;
            *.tbz2)      tar xjf $1  ;;
            *.tgz)       tar xzf $1  ;;
            *.zip)       unzip $1   ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1  ;;
            *)        echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}
function _compressed_files() {
  local cur
  cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( $(find .  -type f ! -name '.*' -name "$cur*.tar.bz2" -o -name "$cur*.tar.gz" \
                -o -name "$cur$.bz2" -o -name "$cur*.rar" -o -name "$cur$.gz" \
                -o -name "$cur*.tar" -o -name "$cur$.tbz2" -o -name "$cur*.tgz" \
                -o -name "$cur*.zip" -o -name "$cur$.Z" -o -name "$cur*.7z" \
                 | xargs -n1 basename) )
}
complete -F _compressed_files extract


# handy alias if no argutmet equivalent to git lg
# other plain old git but two letter less
# credit to https://github.com/pengwynn/dotfiles
function g() {
    if [[ $# -gt 0 ]]; then
        git "$@"
    else
        git status --short --branch
    fi
}

function t() {
  tig "$@"
}

complete -F _tig t


# autocomplete g like it is git yeah!
__git_complete g __git_main

function v() {
    if [[ $# -gt 0 ]]; then
        vagrant "$@"
    else
        vagrant status
    fi
}


qh() {
  grep --color=always "$*" "$HISTFILE" |       less -RX
}

# fzf integrations see https://junegunn.kr/2016/07/fzf-git/
is_in_git_repo() {
  git rev-parse HEAD > /dev/null 2>&1
}

fzf-down() {
  fzf --height 50% "$@" --border
}

gb() {
  is_in_git_repo || return
  git branch  | grep -v '/HEAD\s' | sort |
  fzf-down --ansi --multi --tac --preview-window right:70% \
    --preview 'git lg -5 $(sed s/^..// <<< {} | cut -d" " -f1) | head -'$LINES |
  sed 's/^..//' | cut -d' ' -f1 |
  sed 's#^remotes/##'
}

bind '"\C-g\C-b": "$(gb)\e\C-e\er"'

# edit conflic in vim and setup search pattern with conflic marker
# credit to https://coderwall.com/p/psa3ng
function editconflicts() {
  vim +/"<<<<<<<" -p "$(git diff --name-only --diff-filter=U | xargs)"
}

function prev() {
  PREV=$(fc -lrn | head -n 1)
  sh -c "pet new `printf %q "$PREV"`"
}

fvim() {
  local IFS=$'\n'
  local files=($(fzf --query="$1" --multi --select-1 --exit-0))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}
bind -x '"\C-p": fvim'

fbr() {
  local branches branch
  branches=$(git branch) &&
  branch=$(echo "$branches" | fzf +m) &&
  git checkout "$(echo "$branch" | awk '{print $1}' | sed "s/.* //")"
}

bind -x '"\C-b": fbr'

function treed() {
  tree -aC -I ".git" --dirsfirst "$@" | less -FRNX
}
