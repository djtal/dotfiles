# vim:syntax=sh


function cddev() {
  # dir=$(find ~/ciblo/projets -type d -mindepth 1 -maxdepth 2 -name "$1" | head -n 1)
  dir=$(find ~/Developement/Projects -mindepth 1 -maxdepth 2 -name "$1" -type d | head -n 1)
  if [ "$dir" ]; then
    cd "$dir"
    echo -ne "\033]0;$1\007"
  else
    echo "Aucun projet '$1' trouvÃ©..." >&2
    return 1
  fi
}

function _devs() {
  local cur
  cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( $(find ~/Developement/Projects -mindepth 1 -maxdepth 2 ! -name '.*' -name "$cur*" -type d -exec basename {} \;) )
}
complete -F _devs cddev

# Tmux shortcurt
# see https://gist.github.com/jyurek/7be666a88e06f68d45cf
tm() {
  if [ -z "$TMUX" ]; then
    # not in tmux
    tmux new-session -As $1
  else
    # inside tmux
    if [ tmux has-session $1 ]; then
      tmux switch-client -t $1
    else
      TMUX= tmux new-session -ds $1
      tmux switch-client -t $1
    fi
 fi
}

# AUtocompletion for tmux sessions
# see https://gist.github.com/jyurek/7be666a88e06f68d45cf
_tmux_complete_session() {
  local IFS=$'\n'
  local cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( ${COMPREPLY[@]:-} $(compgen -W "$(tmux -q list-sessions | cut -f 1 -d ':')" -- "${cur}") )
}
complete -F _tmux_complete_session tm

# Pow managment

# easy add app rails app to pow
#
function power() {
  app_path=$(pwd)
  app_name=$1
  : ${app_name:="$(basename $app_path)"}
  ln -nfs $app_path ~/.pow/$app_name
  echo "application avalaible at ${app_name}.dev"
}

function powlog() {
  app_path=$(pwd)
  app_name=$1
  : ${app_name:="$(basename $app_path)"}
  tail -f /Users/djtal/Library/Logs/Pow/apps/${app_name}.log
}

function repow() {
  launchctl stop cx.pow.powd
}

function powaaaa {
  curl --silent -H host:pow localhost/status.json | python -mjson.tool
}

# Quick Rails 2.3 alias

function rdm() { bundle exec rake db:migrate "$@"; }
function rsc() {
  if [ -f script/console ]; then
    bundle exec script/console "$@";
  elif [ -d bin ]; then
    bundle exec bin/rails c
  else
    bundle exec rails c "$@"
  fi
  }
function sdc() { ./script/dbconsole -p "$@"; }
function tlf() { tail -f log/${RAILS_ENV:-development}.log; }

# extract any time of compressed file
# source https://coderwall.com/p/arwifq?i=9&p=1&q=sort%3Ascore+desc&t%5B%5D=bash
function extract {
    echo Extracting $1 ...
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xjf $1  ;;
            *.tar.gz)    tar xzf $1  ;;
            *.bz2)       bunzip2 $1  ;;
            *.rar)       rar x $1    ;;
            *.gz)        gunzip $1   ;;
            *.tar)       tar xf $1   ;;
            *.tbz2)      tar xjf $1  ;;
            *.tgz)       tar xzf $1  ;;
            *.zip)       unzip $1   ;;
            *.Z)         uncompress $1  ;;
            *.7z)        7z x $1  ;;
            *)        echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}
function _compressed_files() {
  local cur
  cur=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=( $(find . -type f ! -name '.*' -name "$cur*.tar.bz2" -o -name "$cur*.tar.gz" \
                -o -name "$cur$.bz2" -o -name "$cur*.rar" -o -name "$cur$.gz" \
                -o -name "$cur*.tar" -o -name "$cur$.tbz2" -o -name "$cur*.tgz" \
                -o -name "$cur*.zip" -o -name "$cur$.Z" -o -name "$cur*.7z" \
                | xargs -n1 basename) )
}
complete -F _compressed_files extract


# handy alias if no argutmet equivalent to git lg
# other plain old git but two letter less
# credit to https://github.com/pengwynn/dotfiles
function g {
    if [[ $# > 0 ]]; then
        git $@
    else
        git status --short --branch
    fi
}

# autocomplete g like it is git yeah!
__git_complete g __git_main

function v {
    if [[ $# > 0 ]]; then
        vagrant $@
    else
        vagrant status
    fi
}


qh() {
  grep --color=always "$*" "$HISTFILE" |       less -RX
}

# fzf integrations see https://junegunn.kr/2016/07/fzf-git/
is_in_git_repo() {
  git rev-parse HEAD > /dev/null 2>&1
}

fzf-down() {
  fzf --height 50% "$@" --border
}

gb() {
  is_in_git_repo || return
  git branch  | grep -v '/HEAD\s' | sort |
  fzf-down --ansi --multi --tac --preview-window right:70% \
    --preview 'git lg -5 $(sed s/^..// <<< {} | cut -d" " -f1) | head -'$LINES |
  sed 's/^..//' | cut -d' ' -f1 |
  sed 's#^remotes/##'
}

bind '"\C-g\C-b": "$(gb)\e\C-e\er"'

# edit conflic in vim and setup search pattern with conflic marker
# credit to https://coderwall.com/p/psa3ng
function editconflicts() {
  vim +/"<<<<<<<" $( git diff --name-only --diff-filter=U | xargs )
}

function prev() {
  PREV=$(fc -lrn | head -n 1)
  sh -c "pet new `printf %q "$PREV"`"
}

function ktty() {
  selected=$(kubectl get pods  -o=jsonpath="{.items[*].metadata.labels.app}" | tr ' ' '\n' | uniq | fzf --header='App :')
  if [[ ! -z "$selected" ]]; then
    pod=$(kubectl get pod -l "app=$selected" -o jsonpath='{.items[0].metadata.name}')
    if [[ ! -z "$pod" ]]; then
      kubectl exec -ti "$pod" -- /bin/ash
    fi
  fi
}
